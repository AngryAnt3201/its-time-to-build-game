use hecs::World;
use rand::Rng;

use crate::ecs::components::{
    Building, Collider, GamePhase, GameState, Health, Position, Rogue, RogueAI,
    RogueBehaviorState, RogueType, RogueVisibility, Velocity,
};
use crate::protocol::RogueTypeKind;

/// Ticks between cascade waves (30 seconds at 20 Hz).
const CASCADE_WAVE_INTERVAL: u64 = 600;

/// Total number of cascade waves before the cascade ends.
const CASCADE_TOTAL_WAVES: u64 = 10;

/// Ticks after city_reached_tick before cascade begins (matches progression.rs).
const CASCADE_DELAY: u64 = 6000;

/// Result returned by [`spawn_system`] each tick.
pub struct SpawnResult {
    /// Log messages generated by the spawn system (e.g. cascade events).
    pub log_entries: Vec<String>,
}

/// Runs the spawn system for a single tick.
///
/// Determines whether to spawn a new rogue enemy based on the current game
/// phase and building count, then places it at a random position around the
/// player.  When the cascade is active, delegates to [`cascade_spawn`] instead
/// of normal probabilistic spawning.
pub fn spawn_system(
    world: &mut World,
    game_state: &mut GameState,
    player_x: f32,
    player_y: f32,
) -> SpawnResult {
    // ── If spawning is disabled via debug, skip all spawning ──────────
    if !game_state.spawning_enabled {
        return SpawnResult {
            log_entries: Vec::new(),
        };
    }

    // ── If cascade is active, use cascade spawning ────────────────────
    if game_state.cascade_active {
        return cascade_spawn(world, game_state, player_x, player_y);
    }

    let mut rng = rand::thread_rng();

    // ── Count buildings for scaling spawn rate ─────────────────────────
    let building_count = world.query::<&Building>().iter().count() as f32;

    // ── Base spawn rate by phase ──────────────────────────────────────
    let base_rate = match game_state.phase {
        GamePhase::Hut => 0.0002,
        GamePhase::Outpost => 0.0005,
        GamePhase::Village => 0.001,
        GamePhase::Network => 0.002,
        GamePhase::City => 0.003,
    };

    let spawn_chance = base_rate + building_count * 0.0002;

    // ── Roll for spawn ────────────────────────────────────────────────
    if rng.gen::<f32>() > spawn_chance {
        return SpawnResult {
            log_entries: Vec::new(),
        };
    }

    // ── Spawn position: random angle, 300-500 units from player ───────
    let angle = rng.gen::<f32>() * std::f32::consts::TAU;
    let distance = rng.gen_range(300.0..500.0_f32);
    let spawn_x = player_x + angle.cos() * distance;
    let spawn_y = player_y + angle.sin() * distance;

    // ── Choose rogue type based on game phase ─────────────────────────
    let roll: f32 = rng.gen();
    let rogue_kind = match game_state.phase {
        GamePhase::Hut => {
            if roll < 0.70 {
                RogueTypeKind::Swarm
            } else {
                RogueTypeKind::Corruptor
            }
        }
        GamePhase::Outpost => {
            if roll < 0.40 {
                RogueTypeKind::Swarm
            } else if roll < 0.70 {
                RogueTypeKind::Corruptor
            } else if roll < 0.85 {
                RogueTypeKind::Looper
            } else {
                RogueTypeKind::TokenDrain
            }
        }
        GamePhase::Village | GamePhase::Network | GamePhase::City => {
            if roll < 0.25 {
                RogueTypeKind::Swarm
            } else if roll < 0.45 {
                RogueTypeKind::Corruptor
            } else if roll < 0.60 {
                RogueTypeKind::Looper
            } else if roll < 0.75 {
                RogueTypeKind::TokenDrain
            } else if roll < 0.85 {
                RogueTypeKind::Assassin
            } else if roll < 0.95 {
                RogueTypeKind::Mimic
            } else {
                RogueTypeKind::Architect
            }
        }
    };

    spawn_rogue(world, spawn_x, spawn_y, rogue_kind);

    SpawnResult {
        log_entries: Vec::new(),
    }
}

/// Cascade wave spawning — called when `game_state.cascade_active` is true.
///
/// Spawns waves of ALL enemy types simultaneously, scaling in intensity.
/// After 10 waves (5 minutes) the cascade ends.
fn cascade_spawn(
    world: &mut World,
    game_state: &mut GameState,
    player_x: f32,
    player_y: f32,
) -> SpawnResult {
    let mut log_entries: Vec<String> = Vec::new();

    let city_tick = match game_state.city_reached_tick {
        Some(t) => t,
        None => {
            // Shouldn't happen, but safety fallback
            game_state.cascade_active = false;
            return SpawnResult { log_entries };
        }
    };

    // Cascade starts at city_reached_tick + CASCADE_DELAY
    let cascade_start = city_tick + CASCADE_DELAY;
    if game_state.tick < cascade_start {
        return SpawnResult { log_entries };
    }

    let ticks_into_cascade = game_state.tick - cascade_start;
    let wave_number = ticks_into_cascade / CASCADE_WAVE_INTERVAL;

    // ── Check if cascade is over ──────────────────────────────────────
    if wave_number >= CASCADE_TOTAL_WAVES {
        game_state.cascade_active = false;
        log_entries.push("[sys] the cascade breaks. you endured.".to_string());
        log_entries.push("[sys] build complete. what's next?".to_string());
        return SpawnResult { log_entries };
    }

    // ── Only spawn at the exact start of each wave ────────────────────
    let ticks_into_wave = ticks_into_cascade % CASCADE_WAVE_INTERVAL;
    if ticks_into_wave != 0 {
        return SpawnResult { log_entries };
    }

    log_entries.push(format!(
        "[sys] cascade wave {} incoming.",
        wave_number + 1
    ));

    // ── Determine counts per enemy type for this wave ─────────────────
    let w = wave_number as i32;

    let swarm_count = 5 + w * 2;
    let corruptor_count = 2 + w;
    let looper_count = 1 + w;
    let token_drain_count = 1 + w;
    let assassin_count = if w >= 1 { 1 + (w - 1) } else { 0 };
    let mimic_count = if w >= 2 { w - 1 } else { 0 };
    let architect_count = if w >= 4 { 1 + (w - 4) } else { 0 };

    // ── Spawn all enemies in a ring around the player ─────────────────
    let spawn_list: Vec<(RogueTypeKind, i32)> = vec![
        (RogueTypeKind::Swarm, swarm_count),
        (RogueTypeKind::Corruptor, corruptor_count),
        (RogueTypeKind::Looper, looper_count),
        (RogueTypeKind::TokenDrain, token_drain_count),
        (RogueTypeKind::Assassin, assassin_count),
        (RogueTypeKind::Mimic, mimic_count),
        (RogueTypeKind::Architect, architect_count),
    ];

    let mut rng = rand::thread_rng();

    for (kind, count) in &spawn_list {
        for _ in 0..*count {
            let angle = rng.gen::<f32>() * std::f32::consts::TAU;
            let distance = rng.gen_range(250.0..400.0_f32);
            let spawn_x = player_x + angle.cos() * distance;
            let spawn_y = player_y + angle.sin() * distance;
            spawn_rogue(world, spawn_x, spawn_y, *kind);
        }
    }

    SpawnResult { log_entries }
}

/// Spawns a single rogue entity of the given type at the given position.
pub fn spawn_rogue(world: &mut World, x: f32, y: f32, rogue_kind: RogueTypeKind) {
    // ── HP and damage by type ─────────────────────────────────────────
    let (hp, _damage) = match rogue_kind {
        RogueTypeKind::Swarm => (15, 3),
        RogueTypeKind::Corruptor => (40, 5),
        RogueTypeKind::Looper => (25, 2),
        RogueTypeKind::TokenDrain => (20, 1),
        RogueTypeKind::Assassin => (35, 15),
        RogueTypeKind::Mimic => (30, 8),
        RogueTypeKind::Architect => (80, 10),
    };

    // ── Visibility: TokenDrain starts invisible ───────────────────────
    let visible = rogue_kind != RogueTypeKind::TokenDrain;

    // ── Spawn the rogue entity ────────────────────────────────────────
    world.spawn((
        Rogue,
        Position { x, y },
        Velocity::default(),
        Collider { radius: 6.0 },
        Health {
            current: hp,
            max: hp,
        },
        RogueType { kind: rogue_kind },
        RogueAI {
            behavior_state: RogueBehaviorState::Wandering,
            target: None,
        },
        RogueVisibility { visible },
    ));
}
