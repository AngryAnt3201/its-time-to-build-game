use hecs::World;

use crate::ecs::components::{
    Agent, AgentName, AgentState, CombatPower, GameState, Health, Player, Position, Rogue,
    RogueType,
};
use crate::protocol::{AgentStateKind, AudioEvent, RogueTypeKind};

/// The result of running the combat system for one tick.
pub struct CombatResult {
    /// Rogues that were killed this tick, with their type.
    pub killed_rogues: Vec<(hecs::Entity, RogueTypeKind)>,
    /// Agents that were killed this tick, with their name.
    pub killed_agents: Vec<(hecs::Entity, String)>,
    /// Whether the player took damage this tick.
    pub player_damaged: bool,
    /// Log lines generated by combat events.
    pub log_entries: Vec<String>,
    /// Audio events triggered by combat.
    pub audio_events: Vec<AudioEvent>,
    /// Bounty tokens earned from rogue kills.
    pub bounty_tokens: i64,
}

/// Returns the squared distance between two positions.
fn distance_sq(a: &Position, b: &Position) -> f32 {
    let dx = a.x - b.x;
    let dy = a.y - b.y;
    dx * dx + dy * dy
}

/// Returns the bounty (in tokens) for killing a rogue of the given type.
fn bounty_for(kind: RogueTypeKind) -> i64 {
    match kind {
        RogueTypeKind::Swarm => 5,
        RogueTypeKind::Corruptor => 15,
        RogueTypeKind::Looper => 10,
        RogueTypeKind::TokenDrain => 12,
        RogueTypeKind::Assassin => 30,
        RogueTypeKind::Mimic => 15,
        RogueTypeKind::Architect => 50,
    }
}

/// Returns the damage a rogue deals to the player per tick.
fn rogue_damage_to_player(kind: RogueTypeKind) -> i32 {
    match kind {
        RogueTypeKind::Swarm => 1,
        RogueTypeKind::Corruptor => 2,
        RogueTypeKind::Looper => 1,
        RogueTypeKind::Assassin => 5,
        RogueTypeKind::Mimic => 3,
        RogueTypeKind::TokenDrain => 0, // drains tokens instead
        RogueTypeKind::Architect => 3,
    }
}

/// Returns the damage a rogue deals to agents per tick.
fn rogue_damage_to_agent(kind: RogueTypeKind) -> i32 {
    match kind {
        RogueTypeKind::Assassin => 8,
        RogueTypeKind::Corruptor => 3,
        _ => 2,
    }
}

/// Runs the combat system for a single tick.
///
/// * `world` -- mutable reference to the ECS world.
/// * `game_state` -- mutable reference to the global game state (for token drain).
/// * `player_attacking` -- whether the player performed an attack action this tick.
///
/// Returns a [`CombatResult`] with all combat events that occurred.
pub fn combat_system(
    world: &mut World,
    game_state: &mut GameState,
    player_attacking: bool,
) -> CombatResult {
    let mut result = CombatResult {
        killed_rogues: Vec::new(),
        killed_agents: Vec::new(),
        player_damaged: false,
        log_entries: Vec::new(),
        audio_events: Vec::new(),
        bounty_tokens: 0,
    };

    // ── Gather player info ──────────────────────────────────────────
    let mut player_pos: Option<Position> = None;
    let mut player_damage: i32 = 0;
    let mut player_entity: Option<hecs::Entity> = None;

    for (entity, (_player, pos, combat)) in
        world.query::<(&Player, &Position, &CombatPower)>().iter()
    {
        player_pos = Some(pos.clone());
        player_damage = combat.base_damage;
        player_entity = Some(entity);
    }

    // If there is no player in the world, nothing to do.
    let player_pos = match player_pos {
        Some(p) => p,
        None => return result,
    };

    // ── Gather rogue info ───────────────────────────────────────────
    // We collect into a Vec to avoid borrowing `world` while we mutate it later.
    let rogues: Vec<(hecs::Entity, Position, RogueTypeKind)> = world
        .query::<(&Rogue, &Position, &RogueType)>()
        .iter()
        .map(|(entity, (_rogue, pos, rogue_type))| (entity, pos.clone(), rogue_type.kind))
        .collect();

    // ── Player attacks nearby rogues ────────────────────────────────
    let attack_range_sq: f32 = 30.0 * 30.0;

    if player_attacking {
        for &(rogue_entity, ref rogue_pos, rogue_kind) in &rogues {
            if distance_sq(&player_pos, rogue_pos) > attack_range_sq {
                continue;
            }

            // Apply damage to the rogue's health.
            if let Ok(mut health) = world.get::<&mut Health>(rogue_entity) {
                health.current -= player_damage;

                result.audio_events.push(AudioEvent::CombatHit);

                if health.current <= 0 {
                    let bounty = bounty_for(rogue_kind);
                    result.bounty_tokens += bounty;
                    result.killed_rogues.push((rogue_entity, rogue_kind));
                    result
                        .log_entries
                        .push(format!("[combat] {:?} terminated", rogue_kind));
                }
            }
        }
    }

    // ── Rogues attack player (proximity-based) ──────────────────────
    let player_threat_range_sq: f32 = 20.0 * 20.0;

    for &(_rogue_entity, ref rogue_pos, rogue_kind) in &rogues {
        if distance_sq(&player_pos, rogue_pos) > player_threat_range_sq {
            continue;
        }

        // TokenDrain special: drain 1 token from economy instead of HP.
        if rogue_kind == RogueTypeKind::TokenDrain {
            game_state.economy.balance = (game_state.economy.balance - 1).max(0);
            continue;
        }

        let dmg = rogue_damage_to_player(rogue_kind);
        if dmg > 0 {
            if let Some(pe) = player_entity {
                if let Ok(mut health) = world.get::<&mut Health>(pe) {
                    health.current -= dmg;
                    result.player_damaged = true;
                }
            }
        }
    }

    // ── Rogues attack nearby agents ─────────────────────────────────
    let agent_threat_range_sq: f32 = 25.0 * 25.0;

    // Gather live agents.
    let agents: Vec<(hecs::Entity, Position, String)> = world
        .query::<(&Agent, &Position, &AgentState, &AgentName)>()
        .iter()
        .filter(|(_entity, (_agent, _pos, state, _name))| {
            state.state != AgentStateKind::Unresponsive
        })
        .map(|(entity, (_agent, pos, _state, name))| (entity, pos.clone(), name.name.clone()))
        .collect();

    for (agent_entity, ref agent_pos, ref agent_name) in &agents {
        for &(_rogue_entity, ref rogue_pos, rogue_kind) in &rogues {
            if distance_sq(agent_pos, rogue_pos) > agent_threat_range_sq {
                continue;
            }

            let dmg = rogue_damage_to_agent(rogue_kind);
            if let Ok(mut health) = world.get::<&mut Health>(*agent_entity) {
                health.current -= dmg;

                if health.current <= 0 {
                    // Mark agent as unresponsive.
                    if let Ok(mut agent_state) = world.get::<&mut AgentState>(*agent_entity) {
                        agent_state.state = AgentStateKind::Unresponsive;
                    }
                    result
                        .killed_agents
                        .push((*agent_entity, agent_name.clone()));
                    result.log_entries.push(format!(
                        "[agent_{}] has stopped responding.",
                        agent_name
                    ));
                    result.audio_events.push(AudioEvent::AgentDeath);
                    // Agent is dead -- stop processing more rogue hits for them.
                    break;
                }
            }
        }
    }

    // ── Despawn killed rogues ────────────────────────────────────────
    for &(rogue_entity, _kind) in &result.killed_rogues {
        let _ = world.despawn(rogue_entity);
    }

    // ── Apply bounty tokens to economy ──────────────────────────────
    game_state.economy.balance += result.bounty_tokens;

    result
}
