use hecs::World;

use crate::ecs::components::{
    Building, BuildingType, ConstructionProgress, GamePhase, GameState,
};
use crate::game::building::get_building_definition;
use crate::protocol::BuildingTypeKind;

/// The number of ticks after reaching City phase before the cascade triggers.
/// At 20 Hz this is 6000 ticks = 5 minutes.
const CASCADE_TICK_THRESHOLD: u64 = 6000;

/// Result returned by [`progression_system`] each tick.
pub struct ProgressionResult {
    /// Whether the game phase changed this tick.
    pub phase_changed: bool,
    /// The new phase, if a transition occurred.
    pub new_phase: Option<GamePhase>,
    /// Log messages generated by the progression system.
    pub log_entries: Vec<String>,
    /// Whether the cascade was triggered this tick.
    pub cascade_triggered: bool,
}

/// Examines the world for completed buildings, counts them by tier, and checks
/// whether a phase transition should occur.  Also manages the cascade trigger
/// once the City phase has been reached for long enough.
pub fn progression_system(
    world: &World,
    game_state: &mut GameState,
) -> ProgressionResult {
    let mut result = ProgressionResult {
        phase_changed: false,
        new_phase: None,
        log_entries: Vec::new(),
        cascade_triggered: false,
    };

    // ── Count completed buildings by tier ─────────────────────────────
    let mut tier_counts: [u32; 5] = [0; 5]; // indices 0..4
    let mut has_pylon = false;

    for (_entity, (building_type, construction)) in
        world.query::<(&BuildingType, &ConstructionProgress)>().with::<&Building>().iter()
    {
        // A building counts as complete when current >= total
        if construction.current >= construction.total {
            let def = get_building_definition(&building_type.kind);
            let tier = def.tier as usize;
            if tier < tier_counts.len() {
                tier_counts[tier] += 1;
            }

            if building_type.kind == BuildingTypeKind::Pylon {
                has_pylon = true;
            }
        }
    }

    // ── Check phase transitions ──────────────────────────────────────
    let transition = match game_state.phase {
        GamePhase::Hut => {
            // Hut -> Outpost: 2+ Tier 1 buildings AND first Pylon complete
            if tier_counts[1] >= 2 && has_pylon {
                Some((
                    GamePhase::Outpost,
                    "[sys] the darkness has noticed you.".to_string(),
                ))
            } else {
                None
            }
        }
        GamePhase::Outpost => {
            // Outpost -> Village: 2+ Tier 2 buildings
            if tier_counts[2] >= 2 {
                Some((
                    GamePhase::Village,
                    "[sys] they're sending more. build faster.".to_string(),
                ))
            } else {
                None
            }
        }
        GamePhase::Village => {
            // Village -> Network: 2+ Tier 3 buildings
            if tier_counts[3] >= 2 {
                Some((
                    GamePhase::Network,
                    "[sys] your agents are talking to each other now. that's new.".to_string(),
                ))
            } else {
                None
            }
        }
        GamePhase::Network => {
            // Network -> City: Blockchain complete
            if tier_counts[4] >= 1 {
                Some((
                    GamePhase::City,
                    "[sys] the cascade approaches.".to_string(),
                ))
            } else {
                None
            }
        }
        GamePhase::City => None,
    };

    // ── Apply transition ─────────────────────────────────────────────
    if let Some((new_phase, thematic_message)) = transition {
        let old_name = phase_name(&game_state.phase);
        let new_name = phase_name(&new_phase);

        result
            .log_entries
            .push(format!("[sys] phase transition: {} \u{2192} {}", old_name, new_name));
        result.log_entries.push(thematic_message);

        // If we just reached City, record the tick
        if matches!(new_phase, GamePhase::City) {
            game_state.city_reached_tick = Some(game_state.tick);
        }

        game_state.phase = new_phase.clone();
        result.phase_changed = true;
        result.new_phase = Some(new_phase);
    }

    // ── Cascade check ────────────────────────────────────────────────
    if matches!(game_state.phase, GamePhase::City) && !game_state.cascade_active {
        if let Some(city_tick) = game_state.city_reached_tick {
            if game_state.tick.saturating_sub(city_tick) >= CASCADE_TICK_THRESHOLD {
                game_state.cascade_active = true;
                result.cascade_triggered = true;
                result
                    .log_entries
                    .push("[sys] THE CASCADE HAS BEGUN.".to_string());
            }
        }
    }

    result
}

/// Returns a human-readable label for a [`GamePhase`].
fn phase_name(phase: &GamePhase) -> &'static str {
    match phase {
        GamePhase::Hut => "Hut",
        GamePhase::Outpost => "Outpost",
        GamePhase::Village => "Village",
        GamePhase::Network => "Network",
        GamePhase::City => "City",
    }
}
